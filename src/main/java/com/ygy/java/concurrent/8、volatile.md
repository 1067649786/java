# 8 volatile

## 8.1 几个基本概念

在介绍volatile之前，我们先回顾及介绍几个基本概念。

### 8.1.1 内存可见性

在Java内存模型那一章我们介绍了JMM有一个主内存，每个线程有自己私有的工作内存，工作内存
中保存了一些变量在主内存的拷贝。<br>

**内存可见性，指的是线程之间的可见性，当一个线程修改了共享变量时，另一个线程可以读取到这个修改后的值**。<br>

### 8.1.2 重排序

为优化程序性能，对原有的指令执行顺序进行优化重新排序。重排序可能发生在多个阶段，比如编译重排序，CPU重排序等。

### 8.1.3 happens-before规则

是一个给程序员使用的规则，只要程序员在写代码的时候遵循happens-before规则，JVM就能
保证指令在多线程之间的顺序符合程序员的预期。

## 8.2 volatile的内存语义

在Java中，volatile关键字有特殊的内存语义。volatile主要有以下两个功能：

- 保证变量的**内存可见性**
- 禁止volatile变量与普通变量**重排序**

## 8.2.1 内存可见性

以一段示例代码开始：

```java
public class VolatileExample {
    int a = 0;
    volatile boolean flag = false;

    public void writer() {
        a = 1; // step 1
        flag = true; // step 2
    }

    public void reader() {
        if (flag) { // step 3
            System.out.println(a); // step 4
        }
    }
}
```

在这段代码里，我们使用volatile关键字修饰了一个boolean类型的变量flag。<br>

所谓内存可见性，指的是当一个线程对volatile修饰的变量进行写操作(比如step2)时，JMM会立即把该线程对应的
本地内存中的共享变量的值刷新到主内存；当一个线程对volatile修饰的变量进行读操作(比如step3)时，JMM会立即
把该线程对应的本地内存置为无效，从主内存中读取共享变量的值。<br>

> 在这一点上，volatile与锁具有相同的内存效果，volatile变量的写和锁的释放具有相同的内存语义，
>volatile变量的读和锁的获取具有相同的内存语义。

<br>

而如果flag变量没有用volatile修饰，在step2，线程A本地内存里面的变量就不会立即更新到主内存，
那随后线程B也同样不会去主内存拿最新的值，仍然使用线程B本地内存缓存的变量值a=0,flag=false。

### 8.2.1 禁止重排序

在JSR-133之前的旧的Java内存模型中，是允许volatile变量与普通变量重排序的。那上面的案例中，
可能就会被重排序成下列时序来执行：

1. 线程A写volatile变量，step2，设置flag为true；
2. 线程B读同一个volatile，step3，读取到flag为true；
3. 线程B读普通变量，step4，读取到a=0；
4. 线程A修改普通变量，step1，设置a=1；

<br>

可见，如果volatile变量与普通变量发生了重排序，虽然volatile变量能保证内存可见性，也可能导致普通变量读取错误。<br>

所以在旧的内存模型中，volatile的写-读就不能与锁的释放-获取具有相同的内存语义了。为了提供一种比锁更轻量级的
**线程间的通信机制**，JSR-133专家组决定增强volatile的内存语义：严格限制编译器和处理器对volatile变量与普通
变量的重排序。<br>

编译器还好说，JVM是怎么还能限制处理器的重排序呢？它是通过**内存屏障**来是实现的。<br>

什么是内存屏障？硬件层面，内存屏障分两种：读屏障和写屏障。内存屏障有两个作用：

1. 阻止屏障两侧的指令重排序；
2. 强制把写缓冲区/高速缓存中的脏数据等写回主内存，或者让缓存中相应的数据失效。

> 注意这里的缓存主要指的是cpu缓存，如L1,L2等。

<br>

编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。编译器选择了一个比较保守的JMM内存屏障
插入策略，这样可以保证在任何处理器平台，任何程序中都能得到正确的volatile内存语义。这个策略是：

- 在每个volatile写操作前插入一个StoreStore屏障；
- 在每个volatile写操作后插入一个StoreLoad屏障；
- 在每个volatile读操作后插入一个LoadLoad屏障；
- 在每个volatile读操作后再插入一个LoadStore屏障。