# 9 synchronized与锁

这篇文章我们来聊一聊Java多线程里面的锁。<br>

首先需要明确的一点：Java多线程的锁都是基于对象的，Java中的每一个对象都可以作为一个锁。<br>

还有一点需要注意的是，我们常听到类锁其实也是对象锁。<br>

Java类只有一个Class对象(可以有多个实例对象，多个实例共享这个Class对象)，而Class对象
也是特殊的Java对象。所以我们常说的类锁，其实就是Class对象的锁。<br>

## 9.1 synchronized关键字

说到锁，我们通常会谈到synchronized这个关键字。它翻译成中文就是同步的意思。<br>

我们通常使用synchronized关键字来给一段代码或一个方法上锁。它通常有以下三种形式：

```java
// 关键字在实例方法上，锁为当前实例
public synchronized void instanceLock() {
    // code
}

// 关键字在静态方法上，锁为当前Class对象
public static synchronized void classLock() {
    // code
}

// 关键字在代码块上，锁为括号里面的对象
public void blockLock() {
    Object o = new Object();
    synchronized (o) {
        // code
    }
}
```

我们这里介绍以下临界区的概念。所谓临界区，指的是某一块代码区域，它同一时刻只能由一个线程执行。
在上面的例子中，如果synchronized关键字在方法上，那临界区就是整个方法内部。而如果是使用synchronized代码块，
那临界区就指的是代码块内部的区域。<br>

通过上面的例子我们可以看到，下面这两个写法其实是等价的作用：

```java
// 关键字在实例方法上，锁为当前实例
public synchronized void instanceLock() {
    // code
}

// 关键字在代码块上，锁为括号里面的对象
public void blockLock() {
    synchronized (this) {
        // code
    }
}
```

同理，下面这两个方法也应该是等价的：

```java
// 关键字在静态方法上，锁为当前Class对象
public static synchronized void classLock() {
    // code
}

// 关键字在代码块上，锁为括号里面的对象
public void blockLock() {
    synchronized (this.getClass()) {
        // code
    }
}
```

## 9.2 几种锁

Java 6为了减少获得锁和释放锁带来的性能消耗，引入了偏向锁和轻量级锁。在Java 6以前，所有的锁都是重量级锁。
所以在Java 6及其以后，一个对象其实有四种锁状态，它们级别由低到高依次是：

1. 无锁状态
2.偏向锁状态
3.轻量级锁状态
4.重量级锁状态

<br>

无锁就是没有对资源进行锁定，任何线程都可以尝试去修改它，无锁在这里不再细讲。<br>

几种锁会随着竞争情况逐渐升级，锁的升级很容易发生，但是锁降级发生的条件会比较苛刻，锁降级发生在Stop The World期间，当
JVM进入安全点的时候，会检查是否有闲置的锁，然后进行降级。

>关于锁降级有两点说明：
>
>1.不同于大部分文章说锁不能降级，实际上HotSpot JVM是支持降级的<br>
>
>2.上面提到的Stop The World期间，以及安全点，这些知识是属于JVM的知识范畴，本文不做细讲。

<br>

下面分别介绍这几种锁以及它们之间的升级。

### 9.2.1 Java对象头

前面我们提到，Java的锁都是基于对象的。首先我们来看看一个对象的锁的信息是存放在什么地方的。<br>

每个Java对象都有对象头。如果是非数组类型，则用2个字宽来存储对象头，如果是数组，则会用3个字宽来存储对象头。
在32位处理器中，一个字宽是32位；在64位虚拟机中，一个字宽是64位。对象头的内存如下表：

| 长度 | 内容 | 说明 |
| ------ | ------ | ------ |
| 32/64bit | Mark Word | 存储对象的hashCode或锁信息等 |
| 32/64bit | Class Metadata Address | 存储到对象类型数据的指针 |
| 32/64bit | Array length | 数组的长度(如果是数组) |

我们主要来看看Mark Word的格式：

| 锁状态 | 29bit或61bit | 1bit 是否是偏向锁 | 2bit 锁标志位 |
| ------ | ------ | ------ | ------ |
| 无锁 |  | 0 | 01 |
| 偏向锁 | 线程ID | 1 | 01 |
| 轻量级锁 | 指向栈中锁记录的指针 | 此时这一位不用于标识偏向锁 | 00 |
| 重量级锁 | 指向互斥量(重量级锁)的指针 | 此时这一位不用于标识偏向锁 | 10 |
| GC标记 | | 此时这一位不用于标识偏向锁 | 11 |

可以看到，当对象状态位偏向锁时，Mark Word存储的是偏向的线程ID；当状态为轻量级锁时，Mark Word存储的是
指向线程栈中Lock Record的指针；当状态为重量级锁时，Mark Word为指向堆中的monitor对象的指针。

### 9.2.2 偏向锁

Hotspot的作者经过以往的研究发现大多数情况下**锁不仅不存在多线程竞争，而且总是由同一线程多次获得**，于是引入了偏向锁。<br>

偏向锁会偏向于第一个访问锁的进程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要出发同步。
也就是说，**偏向锁在资源无竞争的情况下消除了同步语句，连CAS操作都不做了，提高了程序的运行性能**。

>大白话就是对锁置个变量，如果发现为true，代表资源无竞争，则无需再走各种加锁/解锁流程。如果为false，代表
>存在其他线程竞争资源，那么就会走后面的流程。

<br>

**实现原理**<br>

一个线程在第一次进入同步块时，会在对象头和栈帧中的锁记录里存储锁的偏向的线程ID。当下次该线程进入这个同步块时，回去检查锁的Mark Word里面是不是放
的自己的线程ID。<br>

如果是，表明该线程已经获得了锁，以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁；如果不是，
就代表另一个线程来竞争这个偏向锁。这个时候会尝试使用CAS来替换Mark Word里面的线程ID为新线程的ID，这个时候要分两种情况：

- 成功，表示之前的线程不存在了，Mark Word里面的线程ID为新线程的ID，锁不会升级，仍然为偏向锁；
- 失败，表示之前的线程仍然存在，那么暂停之前的线程，设置偏向锁标识为0，并设置锁的标志位为00，升级为轻量级锁，会按照
轻量级锁的方式进行竞争锁。

> CAS：Compare and Swap<br>
>
>比较并设置。用于在硬件层面上提供原子性操作。在Intel处理器中，比较并交换通过指令cmpxchg实现。比较
>是否和给定的数值一致，如果一致则修改，不一致则不修改。


